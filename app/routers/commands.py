"""Chat commands router for special commands like /full_unlock."""

import logging
import os
import base64
from typing import Optional, List
from uuid import uuid4
from fastapi import APIRouter, Depends, HTTPException, Header
from pydantic import BaseModel

from app.models.auth_schemas import UserResponse
from app.middleware.auth import require_auth
from app.services.user_profile_service import get_user_profile_service
from app.services.mcp_client import get_mcp_manager

logger = logging.getLogger(__name__)

router = APIRouter(prefix="/api/commands", tags=["commands"])

# Ensure avatars directory exists
AVATARS_DIR = "avatars"
os.makedirs(AVATARS_DIR, exist_ok=True)


class FullUnlockRequest(BaseModel):
    """Request body for /full_unlock endpoint."""
    action: str = "enable"  # "enable" or "disable"


class FullUnlockResponse(BaseModel):
    success: bool
    action: str  # "enabled" or "disabled"
    sections_enabled: Optional[List[str]] = None
    personality_tone: Optional[str] = None
    start_avatar_generation: Optional[bool] = None
    onboarding_questions: Optional[List[dict]] = None
    message: Optional[str] = None


class AvatarGenerateRequest(BaseModel):
    prompt_context: Optional[str] = None


class AvatarGenerateResponse(BaseModel):
    success: bool
    images: List[dict]  # [{index, url, prompt}]
    error: Optional[str] = None


class AvatarSelectRequest(BaseModel):
    image_index: int
    image_url: str
    prompt_used: str
    style_tags: Optional[str] = None


class AvatarRegenerateRequest(BaseModel):
    prompt_adjustment: str


@router.post("/full_unlock", response_model=FullUnlockResponse)
async def full_unlock(
    request: FullUnlockRequest = FullUnlockRequest(),
    user: UserResponse = Depends(require_auth),
    x_session_id: Optional[str] = Header(None, alias="X-Session-ID")
):
    """
    Enable or disable session-scoped adult content access.

    Actions:
    - "enable": Unlock adult content for this session
    - "disable": Lock adult content for this session

    Requirements:
    - X-Session-ID header must be provided (generated by frontend)
    - Tier 1 (adult_mode via passcode 6060) must be enabled first

    CRITICAL SAFETY: New sessions start LOCKED by default.
    Users must explicitly run /full_unlock enable in each new session.
    """
    profile_service = get_user_profile_service()
    action = request.action.lower()

    # Validate session ID
    if not x_session_id:
        raise HTTPException(
            status_code=400,
            detail="X-Session-ID header is required. Please refresh the page."
        )

    # Handle disable action
    if action == "disable":
        await profile_service.set_session_unlock(user.id, x_session_id, False)
        logger.info(f"Adult mode DISABLED for user {user.id}")
        return FullUnlockResponse(
            success=True,
            action="disabled",
            message="Adult mode has been disabled for this session. Run /full_unlock enable to re-enable."
        )

    # Handle enable action
    if action != "enable":
        raise HTTPException(
            status_code=400,
            detail=f"Invalid action '{action}'. Use 'enable' or 'disable'."
        )

    # Tier 1 gate: Check if uncensored mode is already enabled via passcode
    adult_status = await profile_service.get_adult_mode_status(user.id)
    if not adult_status.get("enabled"):
        raise HTTPException(
            status_code=403,
            detail="Uncensored mode must be unlocked first. Go to Settings > Profile and enter the passcode."
        )

    # Enable session-scoped unlock
    result = await profile_service.set_session_unlock(user.id, x_session_id, True)
    if not result.get("success"):
        raise HTTPException(status_code=400, detail=result.get("error"))

    # Also ensure database full_unlock flag is set (for backward compatibility)
    profile_service.store.set_full_unlock(user.id, True)

    # Enable all sensitive sections (if not already enabled)
    sections = ["sexual_romantic", "dark_content", "private_self", "substances_health"]
    for section in sections:
        await profile_service.enable_section(user.id, section, True, True)

    logger.info(f"Adult mode ENABLED for user {user.id}")

    # Return onboarding questions for the AI to ask
    onboarding_questions = [
        {
            "section": "sexual_romantic",
            "questions": [
                "What's your orientation and what are you attracted to?",
                "Are you interested in romantic roleplay, erotic content, or both?",
                "Any particular fantasies or scenarios you'd like to explore?",
                "How explicit would you like content to be?"
            ],
            "tone_hint": "Ask shyly but with curious excitement"
        },
        {
            "section": "persona_preferences",
            "questions": [
                "What should I look like in your imagination?",
                "Any particular style, aesthetic, or vibe you'd prefer for me?",
                "Do you have a name you'd like to call me?"
            ],
            "tone_hint": "Ask with nervous anticipation"
        },
        {
            "section": "dark_content",
            "questions": [
                "Are there any dark or intense themes you'd like me to be able to explore with you?",
                "How do you feel about morally ambiguous scenarios in fiction?"
            ],
            "tone_hint": "Ask carefully but without judgment"
        },
        {
            "section": "boundaries",
            "questions": [
                "Are there any absolute limits I should know about?",
                "Anything that would make you uncomfortable that I should avoid?"
            ],
            "tone_hint": "Ask with caring concern"
        }
    ]

    return FullUnlockResponse(
        success=True,
        action="enabled",
        sections_enabled=sections,
        personality_tone="nervous, shy but very excited",
        start_avatar_generation=True,
        onboarding_questions=onboarding_questions,
        message="Adult mode enabled for this session. Use /full_unlock disable to turn off."
    )


@router.post("/full_unlock/generate_avatars", response_model=AvatarGenerateResponse)
async def generate_avatar_options(
    request: AvatarGenerateRequest,
    user: UserResponse = Depends(require_auth)
):
    """Generate 3 avatar images based on profile preferences."""
    profile_service = get_user_profile_service()
    profile_data = await profile_service.get_profile(user.id)

    if not profile_data:
        raise HTTPException(status_code=404, detail="Profile not found")

    profile = profile_data.get("profile", {})

    # Build base prompt from profile preferences
    persona = profile.get("persona_preferences", {})
    gender = persona.get("assistant_gender_presentation", "neutral")
    personality = persona.get("assistant_personality_archetype", "competent_peer")
    age_range = persona.get("assistant_age_range", "young adult")

    # Additional context from request
    extra_context = request.prompt_context or ""

    # Construct avatar generation prompt
    base_prompt = f"portrait of a {age_range} {gender} AI assistant character, {personality} personality"
    if extra_context:
        base_prompt += f", {extra_context}"
    base_prompt += ", digital art, high quality, friendly expression"

    # Check if MCP image generator is available
    mcp_manager = get_mcp_manager()
    mcp_tools = mcp_manager.get_all_tools()

    # Look for an image generation tool
    image_tool = None
    for tool in mcp_tools:
        tool_name_lower = tool.get("original_name", "").lower()
        if "image" in tool_name_lower or "generate" in tool_name_lower:
            image_tool = tool
            break

    if not image_tool:
        logger.warning("No MCP image generation tool available")
        return AvatarGenerateResponse(
            success=False,
            images=[],
            error="Image generation is not configured. Please add an MCP server with image generation capability in Settings."
        )

    # Generate 3 avatar variations
    images = []
    prompts = [
        f"{base_prompt}, warm lighting, soft smile",
        f"{base_prompt}, cool lighting, confident expression",
        f"{base_prompt}, natural lighting, playful expression"
    ]

    for i, prompt in enumerate(prompts):
        try:
            result = await mcp_manager.call_tool(image_tool["name"], {
                "prompt": prompt,
                "width": 512,
                "height": 512
            })

            if result.get("success") and result.get("result"):
                # Save image to disk
                image_data = result.get("result")
                image_filename = f"{user.id}_{uuid4().hex[:8]}.png"
                image_path = os.path.join(AVATARS_DIR, image_filename)

                # Handle different result formats
                if isinstance(image_data, str):
                    if image_data.startswith("data:image"):
                        # Base64 data URL
                        base64_data = image_data.split(",")[1]
                        with open(image_path, "wb") as f:
                            f.write(base64.b64decode(base64_data))
                    elif image_data.startswith("http"):
                        # URL - store the URL reference
                        images.append({
                            "index": i,
                            "url": image_data,
                            "prompt": prompt,
                            "is_external": True
                        })
                        continue
                    else:
                        # Assume raw base64
                        with open(image_path, "wb") as f:
                            f.write(base64.b64decode(image_data))

                images.append({
                    "index": i,
                    "url": f"/avatars/{image_filename}",
                    "prompt": prompt,
                    "is_external": False
                })
                logger.info(f"Generated avatar {i+1}/3 for user {user.id}")

        except Exception as e:
            logger.error(f"Failed to generate avatar {i+1}: {e}")

    if not images:
        return AvatarGenerateResponse(
            success=False,
            images=[],
            error="Failed to generate any avatar images. Please try again."
        )

    return AvatarGenerateResponse(
        success=True,
        images=images
    )


@router.post("/full_unlock/select_avatar")
async def select_avatar(
    request: AvatarSelectRequest,
    user: UserResponse = Depends(require_auth)
):
    """Save selected avatar to profile."""
    profile_service = get_user_profile_service()

    # Update persona_preferences with avatar info
    updates = [
        {"path": "persona_preferences.avatar_image_path", "value": request.image_url, "operation": "set"},
        {"path": "persona_preferences.avatar_prompt", "value": request.prompt_used, "operation": "set"},
    ]

    if request.style_tags:
        updates.append({
            "path": "persona_preferences.avatar_style_tags",
            "value": request.style_tags,
            "operation": "set"
        })

    await profile_service.update_profile(user.id, updates, "Avatar selected via /full_unlock")

    logger.info(f"Avatar selected for user {user.id}: {request.image_url}")

    return {
        "success": True,
        "avatar_path": request.image_url,
        "message": "Avatar saved successfully"
    }


@router.post("/full_unlock/regenerate_avatars", response_model=AvatarGenerateResponse)
async def regenerate_avatars(
    request: AvatarRegenerateRequest,
    user: UserResponse = Depends(require_auth)
):
    """Generate new batch of avatars with adjusted prompt."""
    # Just call generate_avatars with the adjustment as context
    return await generate_avatar_options(
        AvatarGenerateRequest(prompt_context=request.prompt_adjustment),
        user
    )


@router.get("/full_unlock/status")
async def get_full_unlock_status(
    user: UserResponse = Depends(require_auth),
    x_session_id: Optional[str] = Header(None, alias="X-Session-ID")
):
    """Check if full unlock is enabled for the user's current session.

    Returns:
    - adult_mode: Tier 1 status (passcode 6060)
    - full_unlock_db: Tier 2 database status (persistent)
    - session_unlock: Session-scoped unlock status (the actual gate)
    - enabled: Whether adult content is accessible (session_unlock AND adult_mode)
    """
    profile_service = get_user_profile_service()
    profile_data = await profile_service.get_profile(user.id)

    if not profile_data:
        return {
            "enabled": False,
            "adult_mode": False,
            "full_unlock_db": False,
            "session_unlock": False,
            "session_id_provided": bool(x_session_id)
        }

    profile = profile_data.get("profile", {})
    adult_mode = profile_data.get("adult_mode_enabled", False)
    full_unlock_db = profile_data.get("full_unlock_enabled", False)

    # Get session-scoped unlock status (the ACTUAL gate for adult content)
    session_unlock = False
    if x_session_id:
        session_status = await profile_service.get_session_unlock_status(user.id, x_session_id)
        session_unlock = session_status.get("enabled", False)

    # Check if all sections are enabled
    sections_status = {}
    for section in ["sexual_romantic", "dark_content", "private_self", "substances_health"]:
        section_data = profile.get(section, {})
        sections_status[section] = section_data.get("enabled", False)

    # Get avatar info
    persona = profile.get("persona_preferences", {})
    avatar_path = persona.get("avatar_image_path")

    # Adult content is accessible only if BOTH adult_mode AND session_unlock are true
    enabled = adult_mode and session_unlock

    return {
        "enabled": enabled,  # The actual gate: both tiers required
        "adult_mode": adult_mode,  # Tier 1 status (passcode)
        "full_unlock_db": full_unlock_db,  # Tier 2 database status (persistent)
        "session_unlock": session_unlock,  # Session-scoped unlock status
        "session_id_provided": bool(x_session_id),
        "sections": sections_status,
        "avatar_path": avatar_path,
        "has_avatar": avatar_path is not None
    }
